### 문제 1

###### 문제 설명

어떤 조직의 직원들은 서로 문자열 메시지를 주고받을 때, 조직 내부에서 공유하는 키 문자열을 사용해 암호화를 거친 후 메시지를 보냅니다. 암호화 방법은 키 문자열을 구성하는 각 문자들을 그 순서를 유지하면서, 보내고자 하는 메시지 사이에 랜덤 하게 끼워 넣는 것입니다.
예를 들어, 보내고자 하는 메시지가 kkxyyz이고, 암호화에 사용할 키 문자열이 abc 라면, a, b, c를 메시지의 중간에 임의로 끼워 넣어 kkaxbycyz와 같이 바꿀 수 있습니다.

암호화된 메시지를 받은 사람은 이를 복호화하여 kkxyyz라는 원본 문자열을 얻고자 합니다. 이를 위해 아래와 같은 단순한 복호화 알고리즘을 고안하였습니다.

1. 키 문자열을 구성하는 각 문자를 암호화된 메시지에서 `순서대로` 찾아내어 제거하고 나머지를 원래 메시지로 간주합니다. 위 예시와 같이 암호화된 메시지가 kkaxbycyz이고 키 문자열이 abc일 경우, 메시지에서 각 키 문자를 제거한 kkxyyz를 원래 메시지로 간주합니다.
2. 여기에서는 키 문자열의 각 문자가 가장 빠른 시점에 매칭 되는 경우를 선택합니다. 예를 들어 암호화된 메시지가 aabcb이고 키 문자열이 ab일 경우, aabcb의 첫 번째 문자인 'a'와 세 번째 문자인 'b'가 제거됩니다. 따라서 acb를 원래 메시지로 간주합니다.

암호화된 메시지 m과 키 문자열 k가 매개변수로 주어집니다. 위 알고리즘을 사용하여 복호화한 문자열을 return 하도록 solution 함수를 완성해주세요.

##### 제한 사항

- m은 길이가 2 이상 10,000,000 이하인 문자열입니다.
- k는 길이가 2 이상 10,000 이하인 문자열입니다.
- k의 길이는 m의 길이보다 항상 작습니다.
- m과 k는 알파벳 소문자로만 구성되어 있습니다.

##### 입출력 예

| m             | k       | result     |
| ------------- | ------- | ---------- |
| `"kkaxbycyz"` | `"abc"` | `"kkxyyz"` |
| `"acbbcdc"`   | `"abc"` | `"cbdc"`   |

##### 입출력 예 설명

입출력 예 #1
k를 구성하는 모든 문자는 m에서 한 번씩 등장하기 때문에, 이를 제외하면 `kkxyyz`가 남게 됩니다. 따라서 `kkxyyz`를 return 합니다.

입출력 예 #2
메시지 m과 k에서 매칭 되는 문자를 빠른 순서대로 대문자로 표현하면, `AcBbCdc`입니다. 매칭 된 문자를 제외하면 `cbdc`가 남게 되고, 이를 return 합니다.



### 문제2

###### 문제 설명

숫자 블록으로 이루어진 피라미드가 있습니다. 각 블록에는 숫자가 적혀있는데, 어떤 블록의 값은 바로 아래에 맞닿아 있는 두 블록의 값을 합한 값입니다. 피라미드의 일부 블록 값이 주어졌을 때 전체 피라미드 구성을 알아내려고 합니다.

아래 그림은 피라미드를 구성하는 일부 블록의 값을 나타냅니다.

![example0_start.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dfb8c356-17b0-4723-80a9-04e801451e56/example0_start.png)

각 층마다 적어도 하나의 블록 값을 알기 때문에 다음과 같이 모든 피라미드의 블록 값을 알아낼 수 있습니다.

![example0_end.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b3a75d46-9875-4b55-85eb-7277a659c348/example0_end.png)

피라미드의 꼭대기 층인 0행부터 마지막 행까지 순서대로, 각 행을 구성하는 블록들 중 하나에 대한 정보를 나타내는 2차원 배열 blocks가 매개변수로 주어집니다. 피라미드를 완성시킨 후, 꼭대기 층부터 제일 아래층까지 순서대로 모두 합친 새로운 배열을 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- blocks의 길이는 1 이상 15 이하입니다.
  - blocks의 i번째 원소는 피라미드 i행을 구성하는 블록 하나에 대한 정보입니다.
  - blocks의 원소는 [a, b] 형식입니다.
  - a는 왼쪽에서 몇 번째 블록인지를 나타내며(맨 왼쪽의 블록이 0번째 블록입니다), i행의 경우 0 이상 i 이하의 정수입니다.
  - b는 블록의 값을 나타내며, -100 이상 100 이하의 정수입니다.

------

##### 입출력 예

| blocks                                           | result                                                       |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `[[0, 50], [0, 22], [2, 10], [1, 4], [4, -13]]`  | `[50, 22, 28, 4, 18, 10, 0, 4, 14, -4, 1, -1, 5, 9, -13]`    |
| `[[0, 92], [1, 20], [2, 11], [1, -81], [3, 98]]` | `[92, 72, 20, 63, 9, 11, 144, -81, 90, -79, 217, -73, -8, 98, -177]` |

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
아래 그림과 같이 피라미드를 채울 수 있습니다.

![example1_end.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dd2fa92f-90d5-4ce6-9994-07f46db709c4/example1_end.png)



### 문제3

###### 문제 설명

네트워크를 통해 전파되는 바이러스가 한 컴퓨터에서 발견되었습니다. 바이러스에 감염된 컴퓨터는 1시간 후 해당 컴퓨터와 직접 연결된 모든 컴퓨터를 바이러스에 감염시킵니다. 관리자는 컴퓨터와 컴퓨터 사이의 연결을 하나씩 끊어 바이러스의 확산을 최대한 막으려고 합니다. 하지만 연결 하나를 끊는 작업 또한 1시간이 걸립니다. 단, 컴퓨터가 감염이 되는 것과 동시에 연결이 끊긴다면 해당 컴퓨터는 감염되지 않는다고 가정합니다.

아래 그림은 컴퓨터 간 네트워크 연결을 나타냅니다. 컴퓨터 n대가 있을 때, 모든 컴퓨터는 0부터 n - 1까지 번호를 부여받습니다. 네트워크는 하나의 트리 구조이며, 최초 감염은 루트 노드에서 일어납니다. 각 노드는 컴퓨터를 나타내며, 화살표는 두 컴퓨터가 직접 연결되어 있음을 나타냅니다.

![example0_start.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f66cf7c3-6f30-486a-b134-af5bb40cfc8b/example0_start.png)

매 시간마다 관리자는 아래 그림과 같이 연결을 끊습니다. 빨간 노드는 감염된 노드를 나타내며, 빨간 화살표는 관리자가 끊어버린 연결을 나타냅니다. 처음에 0번과 1번 사이의 연결을 끊고, 이어서 2번과 6번, 8번과 18번 사이의 연결을 끊습니다.

![example0_end_modified.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/2184580a-9e78-4818-a280-fa9182ee6ddd/example0_end_modified.png)

위 그림과 같이 연결을 끊게 되면 총 7대의 컴퓨터가 감염되며, 다른 어떤 방법을 쓰더라도 감염되는 컴퓨터가 7대보다 적을 수 없습니다.

총 컴퓨터의 수 n과 연결된 두 컴퓨터의 번호를 나타내는 2차원 배열 edges가 매개변수로 주어집니다. 감염된 컴퓨터 수를 최소화하도록 연결을 하나씩 끊을 때, 그때의 감염된 컴퓨터 수를 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- n은 2 이상 50 이하의 자연수입니다.
- edges의 길이는 항상 n - 1 입니다.
  - edges 배열의 원소는 [컴퓨터 번호 A, 컴퓨터 번호 B] 형태입니다.
  - A와 B는 0부터 n - 1 까지 부여된 번호 중 하나입니다.
  - A는 B의 부모 노드입니다.
- 최초 감염 노드는 항상 0번 노드입니다.

------

##### 입출력 예

| n    | edges                                                        | result |
| ---- | ------------------------------------------------------------ | ------ |
| `19` | `[[0, 1], [0, 2], [0, 3], [1, 4], [1, 5], [2, 6], [3, 7], [3, 8], [3, 9], [4, 10], [4, 11], [5, 12], [5, 13], [6, 14], [6, 15], [6, 16], [8, 17], [8, 18]]` | `7`    |
| `14` | `[[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6], [2, 7], [3, 8], [3, 9], [3, 10], [4, 11], [4, 12], [4, 13]]` | `4`    |
| `10` | `[[0, 1], [0, 2], [1, 3], [2, 4], [2, 5], [2, 6], [3, 7], [3, 8], [3, 9]]` | `2`    |

##### 입출력 예 설명

입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
아래 그림은 컴퓨터 간 연결 상태를 나타냅니다.

![example1_end_modfied.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/f7af75b8-d65f-428c-bdbe-8cc79eca693a/example1_end_modfied.png)

먼저 0번과 1번 컴퓨터 사이의 연결을 끊고, 2번과 5번 사이의 연결을 끊으면 됩니다. 감염된 컴퓨터 수는 4이며, 이것이 최솟값입니다.

입출력 예 #3
아래 그림은 컴퓨터 간 연결 상태를 나타냅니다.

![example2_end_modified.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b53b7703-569f-4d8a-9f1b-ae688d0d2b0a/example2_end_modified.png)

먼저 0번과 2번 컴퓨터 사이의 연결을 끊고, 1번과 3번 사이의 연결을 끊으면 됩니다. 감염된 컴퓨터의 수는 2이며, 이것이 최솟값입니다.